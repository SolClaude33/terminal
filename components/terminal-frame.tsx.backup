"use client"

import { useState, useEffect } from "react"
import StatusBar from "./status-bar"
import PriceChart from "./price-chart"
import BettingPanel from "./betting-panel"
import RoundHistory from "./round-history"
import PublicBetsTable from "./public-bets-table"
import Ticker from "./ticker"
import AgeGateModal from "./age-gate-modal"
import { SolanaAPI } from "@/lib/solana-api"

export default function TerminalFrame() {
  const [showAgeGate, setShowAgeGate] = useState(true)
  const [currentTime, setCurrentTime] = useState(new Date())
  const [roundTimeLeft, setRoundTimeLeft] = useState(60)
  const [roundPhase, setRoundPhase] = useState<'betting' | 'waiting'>('waiting')
  const [roundNumber, setRoundNumber] = useState(1)
  const [entryPrice, setEntryPrice] = useState<number | null>(null)
  const [betPrice, setBetPrice] = useState<number | null>(null)
  const [currentPrice, setCurrentPrice] = useState(100.0)
  const [chartPrice, setChartPrice] = useState(100.0)
  const [roundHistory, setRoundHistory] = useState<Array<{
    roundNumber: number
    entryPrice: number
    betPrice: number
    result: 'up' | 'down'
    timestamp: number
  }>>([])
  const [currentRoundEntryPrice, setCurrentRoundEntryPrice] = useState<number | null>(null)
  const [lastRoundEntryPrice, setLastRoundEntryPrice] = useState<number | null>(null)

  // Calculate round phase and time based on global time
  const calculateRoundState = () => {
    const now = new Date()
    const epochSeconds = Math.floor(now.getTime() / 1000)
    
    // Each round cycle is 120 seconds (60 waiting + 60 betting)
    const cyclePosition = epochSeconds % 120
    
    let phase: 'betting' | 'waiting'
    let timeLeft: number
    let roundNum: number
    
    if (cyclePosition < 60) {
      // Waiting phase (betting open)
      phase = 'waiting'
      timeLeft = 60 - cyclePosition
      roundNum = Math.floor(epochSeconds / 120) + 1
    } else {
      // Betting phase (waiting for results)
      phase = 'betting'
      timeLeft = 120 - cyclePosition
      roundNum = Math.floor(epochSeconds / 120) + 1
    }
    
    return { phase, timeLeft, roundNum }
  }

  useEffect(() => {
    // Initialize state based on current time
    const initializeState = () => {
      const now = new Date()
      const { phase, timeLeft, roundNum } = calculateRoundState()
      
      setCurrentTime(now)
      setRoundPhase(phase)
      setRoundTimeLeft(timeLeft)
      setRoundNumber(roundNum)
    }
    
    // Initialize immediately
    initializeState()
    
    // Initialize last round entry price from round history if available
    if (roundHistory.length > 0) {
      const lastRound = roundHistory[roundHistory.length - 1]
      setLastRoundEntryPrice(lastRound.entryPrice)
      console.log(`[INIT] Setting lastRoundEntryPrice from history: $${lastRound.entryPrice.toFixed(2)}`)
    }
    
    const timer = setInterval(() => {
      const now = new Date()
      setCurrentTime(now)
      
      const { phase, timeLeft, roundNum } = calculateRoundState()
      
      // Debug log every 10 seconds
      if (timeLeft % 10 === 0) {
        console.log(`[DEBUG] Phase: ${phase}, Time: ${timeLeft}s, Round: #${roundNum}, ChartPrice: $${chartPrice.toFixed(2)}`)
      }
      
      // Update phase if changed
      if (phase !== roundPhase) {
        console.log(`[PHASE CHANGE] From ${roundPhase} to ${phase} (Round #${roundNum})`)
        setRoundPhase(phase)
        
        // Capture entry price when transitioning from waiting to betting (close betting, start waiting for results)
        if (phase === 'betting' && roundPhase === 'waiting') {
          // Fetch fresh price from DexScreener API at exact transition moment
          const captureEntryPrice = async () => {
            try {
              const solData = await SolanaAPI.getSolanaPriceData()
              const newEntryPrice = solData.price
              
              console.log(`[ENTRY CAPTURE] API Price: $${newEntryPrice.toFixed(2)} (Round #${roundNum})`)
              
              // Store as last round entry price (for display during betting phase)
              setLastRoundEntryPrice(newEntryPrice)
              setEntryPrice(newEntryPrice)
              setCurrentRoundEntryPrice(newEntryPrice)
              
              console.log(`[ROUND] Entry price captured: $${newEntryPrice.toFixed(2)} (Round #${roundNum}) - Betting closed`)
              
              // Log the state after setting
              setTimeout(() => {
                console.log(`[STATE CHECK] currentRoundEntryPrice should be: $${newEntryPrice.toFixed(2)}`)
              }, 100)
            } catch (error) {
              console.error(`[ENTRY CAPTURE ERROR]`, error)
              // Fallback to chart price if API fails
              setLastRoundEntryPrice(chartPrice)
              setEntryPrice(chartPrice)
              setCurrentRoundEntryPrice(chartPrice)
            }
          }
          
          captureEntryPrice()
        }
        
        // Capture bet price when transitioning from betting to waiting (end of results, start new betting)
        if (phase === 'waiting' && roundPhase === 'betting') {
          // Fetch fresh price from DexScreener API at exact transition moment
          const captureBetPrice = async () => {
            try {
              const solData = await SolanaAPI.getSolanaPriceData()
              const finalBetPrice = solData.price
              
              console.log(`[BET CAPTURE] API Price: $${finalBetPrice.toFixed(2)} (Round #${roundNum - 1})`)
              setBetPrice(finalBetPrice)
              
              console.log(`[ROUND] Bet price captured: $${finalBetPrice.toFixed(2)} (Round #${roundNum - 1}) - Calculating results`)
              
              // Add to round history
              const roundEntryPrice = currentRoundEntryPrice || lastRoundEntryPrice || 0
              const roundResult = finalBetPrice > roundEntryPrice ? 'up' : 'down'
              
              console.log(`[HISTORY] Adding round: Entry $${roundEntryPrice.toFixed(2)} â†’ Bet $${finalBetPrice.toFixed(2)} = ${roundResult.toUpperCase()}`)
              
              setRoundHistory(prev => [...prev, {
                roundNumber: roundNum - 1, // Previous round number
                entryPrice: roundEntryPrice,
                betPrice: finalBetPrice,
                result: roundResult,
                timestamp: now.getTime()
              }])
            } catch (error) {
              console.error(`[BET CAPTURE ERROR]`, error)
              // Fallback to chart price if API fails
              const finalBetPrice = chartPrice
              setBetPrice(finalBetPrice)
              
              const roundEntryPrice = currentRoundEntryPrice || lastRoundEntryPrice || 0
              const roundResult = finalBetPrice > roundEntryPrice ? 'up' : 'down'
              
              setRoundHistory(prev => [...prev, {
                roundNumber: roundNum - 1,
                entryPrice: roundEntryPrice,
                betPrice: finalBetPrice,
                result: roundResult,
                timestamp: now.getTime()
              }])
            }
          }
          
          captureBetPrice()
        }
      }
      
      setRoundTimeLeft(timeLeft)
      setRoundNumber(roundNum)
    }, 1000)

    return () => clearInterval(timer)
  }, [roundPhase, chartPrice, currentRoundEntryPrice, lastRoundEntryPrice])

  if (showAgeGate) {
    return <AgeGateModal onConfirm={() => setShowAgeGate(false)} />
  }

  return (
    <div className="min-h-screen bg-background text-foreground font-mono">
      <StatusBar 
        currentTime={currentTime} 
        roundTimeLeft={roundTimeLeft} 
        roundPhase={roundPhase}
        roundNumber={roundNumber}
        entryPrice={entryPrice}
        betPrice={betPrice}
        roundHistory={roundHistory}
      />

      <main className="container mx-auto px-4 py-4">
        <div className="grid grid-cols-1 lg:grid-cols-10 gap-4 mb-4">
          {/* Price Chart - 70% width on desktop */}
          <div className="lg:col-span-7">
            <PriceChart 
              roundTimeLeft={roundTimeLeft} 
              roundPhase={roundPhase}
              onPriceUpdate={setCurrentPrice}
              onChartPriceUpdate={setChartPrice}
            />
          </div>

          {/* Betting Panel - 30% width on desktop */}
          <div className="lg:col-span-3">
          <BettingPanel 
            roundTimeLeft={roundTimeLeft} 
            roundPhase={roundPhase}
            entryPrice={entryPrice}
            betPrice={betPrice}
            currentPrice={chartPrice}
            currentRoundEntryPrice={currentRoundEntryPrice}
            lastRoundEntryPrice={lastRoundEntryPrice}
            roundHistory={roundHistory}
          />
          </div>
        </div>

        {/* Round History */}
        <div className="mb-4">
          <RoundHistory roundHistory={roundHistory} />
        </div>

        {/* Public Bets Table */}
        <div className="mb-4">
          <PublicBetsTable />
        </div>
      </main>

      <Ticker />
    </div>
  )
}